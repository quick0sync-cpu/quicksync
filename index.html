<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real-Time Audio Sync Player</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      padding: 40px;
      max-width: 500px;
      width: 100%;
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 28px;
    }

    .button-group {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
    }

    button {
      flex: 1;
      padding: 15px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .host-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .host-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
    }

    .join-btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
    }

    .join-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(245, 87, 108, 0.4);
    }

    .back-btn {
      background: #6c757d;
      color: white;
      padding: 10px 20px;
      margin-bottom: 20px;
    }

    .back-btn:hover {
      background: #5a6268;
    }

    .waiting-screen {
      text-align: center;
      padding: 40px 0;
    }

    .waiting-screen h2 {
      color: #667eea;
      margin-bottom: 20px;
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .music-player-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 15px;
      padding: 25px;
      color: white;
    }

    .album-art {
      width: 100%;
      height: 200px;
      background: rgba(255,255,255,0.2);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      font-size: 60px;
    }

    .track-info {
      text-align: center;
      margin-bottom: 20px;
    }

    .track-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .track-artist {
      font-size: 14px;
      opacity: 0.8;
    }

    .progress-container {
      margin-bottom: 20px;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(255,255,255,0.3);
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 10px;
    }

    .progress-fill {
      height: 100%;
      background: white;
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s linear;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      opacity: 0.8;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: white;
      color: #667eea;
      border: none;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }

    .control-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .playlist {
      max-height: 400px;
      overflow-y: auto;
    }

    .playlist-item {
      background: #f8f9fa;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .playlist-item:hover {
      background: #e9ecef;
      transform: translateX(5px);
    }

    .playlist-item.playing {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .playlist-icon {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
    }

    .playlist-item.playing .playlist-icon {
      background: white;
      color: #667eea;
    }

    .playlist-info {
      flex: 1;
    }

    .playlist-title {
      font-weight: 600;
      margin-bottom: 3px;
    }

    .playlist-type {
      font-size: 12px;
      opacity: 0.7;
      text-transform: uppercase;
    }

    .hidden {
      display: none;
    }

    audio {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéµ Real-Time Audio Sync</h1>

    <!-- Initial Screen -->
    <div id="initial-screen">
      <div class="button-group">
        <button class="host-btn" onclick="initHost()">Host</button>
        <button class="join-btn" onclick="initJoin()">Join</button>
      </div>
    </div>

    <!-- Waiting Screen for Join Users -->
    <div id="waiting-screen" class="hidden">
      <button class="back-btn" onclick="goBack()">‚Üê Back</button>
      <div class="waiting-screen">
        <h2>Waiting for Audio...</h2>
        <div class="spinner"></div>
        <p style="color: #666; margin-top: 20px;">The host will start playback soon</p>
      </div>
    </div>

    <!-- Host Playlist Screen -->
    <div id="host-screen" class="hidden">
      <button class="back-btn" onclick="goBack()">‚Üê Back</button>
      <h2 style="margin-bottom: 20px; color: #333;">Select a Track</h2>
      <div id="playlist" class="playlist"></div>
    </div>

    <!-- Music Player Screen -->
    <div id="player-screen" class="hidden">
      <button class="back-btn" onclick="stopPlayback()">‚Üê Stop</button>
      <div class="music-player-card">
        <div class="album-art">
          <span id="album-icon">üéµ</span>
        </div>
        <div class="track-info">
          <div class="track-title" id="track-title">Track Title</div>
          <div class="track-artist" id="track-artist">Audio File</div>
        </div>
        <div class="progress-container">
          <div class="progress-bar" id="progress-bar" onclick="seekAudio(event)">
            <div class="progress-fill" id="progress-fill"></div>
          </div>
          <div class="time-display">
            <span id="current-time">0:00</span>
            <span id="total-time">0:00</span>
          </div>
        </div>
        <div class="controls" id="host-controls" style="display: none;">
          <button class="control-btn" onclick="togglePlayPause()">
            <span id="play-pause-icon">‚ñ∂</span>
          </button>
        </div>
      </div>
    </div>

    <audio id="audio-player"></audio>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

        
<script>
  // === CONFIG (keep your existing keys) ===
  const GOOGLE_API_KEY = "AIzaSyCFXR0r0Iv-uMm-O1b3brdeDqYNKmatjRg";
  const DRIVE_FOLDER_ID = "1vCJWwG8rUB9Fod5-QLWbm6cOOE0syrBF";

  // Firebase config (kept same as original)
  const firebaseConfig = {
    apiKey: "AIzaSyCUyBJOM3pGYDeOk1oLEXWiFdLC_Bys4rY",
    authDomain: "quicksync-5d384.firebaseapp.com",
    databaseURL: "https://quicksync-5d384-default-rtdb.asia-southeast1.firebasedatabase.app/",
    projectId: "quicksync-5d384",
    storageBucket: "quicksync-5d384.firebasestorage.app",
    messagingSenderId: "431033998399",
    appId: "1:431033998399:web:5c1884bcfb87b0be6bac8a"
  };

  // === INIT Firebase ===
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();
  const syncRef = database.ref('audioSync');

  // === Globals ===
  let isHost = false;
  let isJoin = false;
  let currentAudio = null;
  let mediaFiles = [];
  let hostHeartbeatInterval = null; // host writes heartbeat every few seconds
  const audioElement = document.getElementById('audio-player');
  audioElement.preload = 'auto';
  audioElement.crossOrigin = 'anonymous';
  audioElement.controls = false;

  // Server time offset handling (important)
  let serverTimeOffset = 0;
  const offsetRef = database.ref('.info/serverTimeOffset');
  offsetRef.on('value', snap => { serverTimeOffset = snap.val() || 0; });

  function serverNow() { // ms
    return Date.now() + (serverTimeOffset || 0);
  }

  // === Fetch files (same logic, kept) ===
  async function fetchMediaFiles() {
    try {
      const url = `https://www.googleapis.com/drive/v3/files?q='${DRIVE_FOLDER_ID}'+in+parents+and+trashed=false&fields=files(id,name,mimeType)&key=${GOOGLE_API_KEY}`;
      const response = await fetch(url);
      const data = await response.json();
      if (data && data.files) {
        mediaFiles = data.files.filter(f => f.mimeType && f.mimeType.startsWith('audio/'));
        return mediaFiles;
      }
      return [];
    } catch (err) {
      console.error('Error fetching media files:', err);
      return [];
    }
  }

  // === UI helpers ===
  function displayPlaylist(files) {
    const playlist = document.getElementById('playlist');
    playlist.innerHTML = '';
    if (!files || files.length === 0) {
      playlist.innerHTML = '<p style="text-align:center; color:#666;">No audio files found</p>';
      return;
    }
    files.forEach((file, i) => {
      const item = document.createElement('div');
      item.className = 'playlist-item';
      item.innerHTML = `
        <div class="playlist-icon">üéµ</div>
        <div class="playlist-info">
          <div class="playlist-title">${file.name}</div>
          <div class="playlist-type">Audio Track</div>
        </div>
      `;
      item.onclick = () => hostChooseTrack(file, i);
      playlist.appendChild(item);
    });
  }

  // === Host flow ===
  async function initHost() {
    isHost = true; isJoin = false;
    document.getElementById('initial-screen').classList.add('hidden');
    document.getElementById('host-screen').classList.remove('hidden');
    const files = await fetchMediaFiles();
    displayPlaylist(files);
  }

  // Host selects track
  function hostChooseTrack(file, index) {
    currentAudio = file;
    // Update UI
    document.getElementById('host-screen').classList.add('hidden');
    document.getElementById('player-screen').classList.remove('hidden');
    document.getElementById('host-controls').style.display = 'flex';
    document.getElementById('track-title').textContent = file.name;
    document.getElementById('track-artist').textContent = 'Audio File';
    // Prepare audio source
    const audioUrl = `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media&key=${GOOGLE_API_KEY}`;
    audioElement.src = audioUrl;
    audioElement.load();

    // schedule start a short time in future to let clients buffer (0.5s)
const startAt = serverNow() + 500;
const cmd = {
  type: 'play',
  isPlaying: true,
  trackId: file.id,
  trackName: file.name,
  startAt: startAt,
  serverTime: serverNow()
};
syncRef.set(cmd).catch(console.error);

// schedule host local playback at the same absolute time
scheduleLocalPlay(startAt);

    // start periodic heartbeat (every 3s) for drift correction (lightweight)
    startHostHeartbeat();
    // update controls icon
    document.getElementById('play-pause-icon').textContent = '‚è∏';
  }

  // Schedule host local play (so host also plays exactly at the scheduled server time)
  function scheduleLocalPlay(startAtMs) {
    let delayMs = startAtMs - serverNow();
    if (delayMs < 0) delayMs = 0;
    schedulePlayAt(audioElement, delayMs);
  }

  // Heartbeat writer for host ‚Äî light weight (every 3000ms)
  function startHostHeartbeat() {
    if (hostHeartbeatInterval) clearInterval(hostHeartbeatInterval);
    hostHeartbeatInterval = setInterval(() => {
      if (audioElement && !audioElement.paused && currentAudio) {
        const hb = {
          type: 'heartbeat',
          isPlaying: true,
          trackId: currentAudio.id,
          trackName: currentAudio.name,
          currentTime: audioElement.currentTime,
          serverTime: serverNow()
        };
        // update (won't overwhelm)
        syncRef.update(hb).catch(console.warn);
      }
    }, 3000000);
  }

  // === Join flow ===
  function initJoin() {
    isJoin = true; isHost = false;
    document.getElementById('initial-screen').classList.add('hidden');
    document.getElementById('waiting-screen').classList.remove('hidden');

    // Listen for control/heartbeat updates
    syncRef.on('value', (snapshot) => {
      const data = snapshot.val();
      if (!data) return;
      if (data.type === 'play' && data.isPlaying) {
        // received new play command
        handlePlayCommand(data);
      } else if (data.type === 'heartbeat' && data.isPlaying) {
        // regular heartbeat ‚Äî use for drift correction
        handleHeartbeat(data);
      } else {
        // not playing
        if (!document.getElementById('player-screen').classList.contains('hidden')) {
          document.getElementById('player-screen').classList.add('hidden');
          document.getElementById('waiting-screen').classList.remove('hidden');
        }
      }
    });
  }

  // Handle play command on joiner
  function handlePlayCommand(data) {
    const audioUrl = `https://www.googleapis.com/drive/v3/files/${data.trackId}?alt=media&key=${GOOGLE_API_KEY}`;
    // update UI
    if (document.getElementById('waiting-screen').classList.contains('hidden') === false) {
      document.getElementById('waiting-screen').classList.add('hidden');
      document.getElementById('player-screen').classList.remove('hidden');
    }
    document.getElementById('track-title').textContent = data.trackName;
    document.getElementById('track-artist').textContent = 'Synced Audio';
    document.getElementById('host-controls').style.display = 'none';

    // load track if different
    if (!audioElement.src || !audioElement.src.includes(data.trackId)) {
      audioElement.src = audioUrl;
      audioElement.load();
    }

    // schedule local playback at absolute server time
    const delayMs = data.startAt - serverNow();
    schedulePlayAt(audioElement, Math.max(0, delayMs));
  }

  // Heartbeat handling: small corrections to keep clients in sync
  function handleHeartbeat(data) {
    // if different track mid-play, ensure loaded
    if (!currentAudio || currentAudio.id !== data.trackId) {
      currentAudio = { id: data.trackId, name: data.trackName };
      const audioUrl = `https://www.googleapis.com/drive/v3/files/${data.trackId}?alt=media&key=${GOOGLE_API_KEY}`;
      audioElement.src = audioUrl;
      audioElement.load();
    }

    // Ensure playing
    if (audioElement.paused) {
      audioElement.play().catch(e => console.warn('Playback call failed:', e));
    }

    
// expected time on client now (in seconds), with bias
const bias = -0.20; // optional bias, play 200ms earlier
const expected = data.currentTime + ((serverNow() - data.serverTime) / 1000.0) + bias;
const delta = audioElement.currentTime - expected; // positive => client ahead

// If very large drift -> hard seek
if (Math.abs(delta) > 0.2) {
  audioElement.currentTime = Math.max(0, expected);
  console.log('Large drift corrected (hard seek)', delta);
} else if (Math.abs(delta) > 0.02) {
  // Small drift: gently adjust playback speed instead of skipping
  const correctionWindowSec = 10; // spread correction over 10s
  let rate = 1 - (delta / correctionWindowSec);
  rate = Math.max(0.98, Math.min(1.02, rate)); // keep within safe limits
  audioElement.playbackRate = rate;

  // reset back to normal speed after a while
  setTimeout(() => { audioElement.playbackRate = 1.0; }, 2000);
}
  }

  // Schedule play at a precise time relative to performance.now
  function schedulePlayAt(audio, delayMs) {
    // ensure some buffer if possible (wait up to a short timeout)
    const minBufferSeconds = Math.min(1, Math.max(0.1, delayMs / 1000)); // at least a bit
    waitForBuffered(audio, 0, minBufferSeconds, Math.max(1000, delayMs + 1500)).then(() => {
      // high resolution scheduling
      const targetPerf = performance.now() + delayMs;
      const doPlay = () => {
        audio.play().catch(err => console.warn('Play failed:', err));
      };
      // recursive scheduling to improve accuracy
      (function scheduleLoop() {
        const rem = targetPerf - performance.now();
        if (rem > 50) {
          setTimeout(scheduleLoop, Math.max(rem - 30, 10));
        } else if (rem > 5) {
          setTimeout(doPlay, rem);
        } else if (rem > 0) {
          requestAnimationFrame(function check() {
            if (performance.now() >= targetPerf) doPlay();
            else requestAnimationFrame(check);
          });
        } else {
          doPlay();
        }
      })();
    }).catch(() => {
      // if waiting fails, just play
      audio.play().catch(err => console.warn('Play fallback failed:', err));
    });
  }

  // Wait for buffered data (simple helper)
  function waitForBuffered(audio, startSec = 0, minSeconds = 0.5, timeoutMs = 5000) {
    return new Promise((resolve) => {
      const deadline = Date.now() + timeoutMs;
      function check() {
        try {
          const buf = audio.buffered;
          if (buf && buf.length) {
            for (let i = 0; i < buf.length; i++) {
              const s = buf.start(i), e = buf.end(i);
              if (startSec >= s && (e - startSec) >= minSeconds) {
                cleanup();
                return resolve();
              }
            }
            // any large range?
            for (let i = 0; i < buf.length; i++) {
              if ((buf.end(i) - buf.start(i)) >= minSeconds) {
                cleanup();
                return resolve();
              }
            }
          }
        } catch (e) { /* ignore */ }
        if (Date.now() > deadline) { cleanup(); return resolve(); }
      }
      const timer = setInterval(check, 180);
      audio.addEventListener('progress', check);
      function cleanup() {
        clearInterval(timer);
        audio.removeEventListener('progress', check);
      }
      check();
    });
  }

  // Update progress UI (same as original)
  function updateProgressBar() {
    if (audioElement.duration && !isNaN(audioElement.duration)) {
      const progress = (audioElement.currentTime / audioElement.duration) * 100;
      document.getElementById('progress-fill').style.width = progress + '%';
      document.getElementById('current-time').textContent = formatTime(audioElement.currentTime);
      document.getElementById('total-time').textContent = formatTime(audioElement.duration);
    }
  }
  audioElement.ontimeupdate = updateProgressBar;

function togglePlayPause() {
  if (!isHost) return;

  if (audioElement.paused) {
    // === PLAY pressed ===
    const startAt = serverNow() + 300; // schedule 0.3s in future
    const playCmd = {
      type: 'play',
      isPlaying: true,
      trackId: currentAudio.id,
      trackName: currentAudio.name,
      startAt,
      serverTime: serverNow()
    };
    // Send immediate play command
    syncRef.set(playCmd).catch(console.error);

    // Play locally at scheduled time
    scheduleLocalPlay(startAt);

    // Start periodic heartbeat (every 30s for drift correction)
    if (hostHeartbeatInterval) clearInterval(hostHeartbeatInterval);
    hostHeartbeatInterval = setInterval(() => {
      if (audioElement && !audioElement.paused && currentAudio) {
        const hb = {
          type: 'heartbeat',
          isPlaying: true,
          trackId: currentAudio.id,
          trackName: currentAudio.name,
          currentTime: audioElement.currentTime,
          serverTime: serverNow()
        };
        syncRef.update(hb).catch(console.warn);
      }
    }, 30000); // 30s interval

    document.getElementById('play-pause-icon').textContent = '‚è∏';
  } else {
    // === PAUSE pressed ===
    audioElement.pause();
    const pauseCmd = {
      type: 'pause',
      isPlaying: false,
      trackId: currentAudio.id,
      trackName: currentAudio.name,
      currentTime: audioElement.currentTime,
      serverTime: serverNow()
    };
    // Send immediate pause command
    syncRef.set(pauseCmd).catch(console.error);

    // Stop heartbeat while paused
    if (hostHeartbeatInterval) { 
      clearInterval(hostHeartbeatInterval); 
      hostHeartbeatInterval = null; 
    }

    document.getElementById('play-pause-icon').textContent = '‚ñ∂';
  }
}

  function stopPlayback() {
    audioElement.pause();
    audioElement.currentTime = 0;
    if (hostHeartbeatInterval) { clearInterval(hostHeartbeatInterval); hostHeartbeatInterval = null; }
    if (isHost) {
      syncRef.set({ type: 'stop', isPlaying: false }).catch(console.error);
      document.getElementById('player-screen').classList.add('hidden');
      document.getElementById('host-screen').classList.remove('hidden');
    } else {
      syncRef.off();
      goBack();
    }
  }

  function goBack() {
    audioElement.pause();
    audioElement.src = '';
    if (hostHeartbeatInterval) { clearInterval(hostHeartbeatInterval); hostHeartbeatInterval = null; }
    if (isJoin) syncRef.off();
    isHost = false; isJoin = false; currentAudio = null;
    document.getElementById('initial-screen').classList.remove('hidden');
    document.getElementById('waiting-screen').classList.add('hidden');
    document.getElementById('host-screen').classList.add('hidden');
    document.getElementById('player-screen').classList.add('hidden');
  }

  function formatTime(seconds) {
    if (isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // Clean up on unload
  window.addEventListener('beforeunload', () => {
    if (isHost && hostHeartbeatInterval) {
      syncRef.set({ type: 'stop', isPlaying: false }).catch(() => {});
    }
    if (isJoin) syncRef.off();
  });
      </script>
  
</body>
</html>
